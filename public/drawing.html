<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Drawing Overlay</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: transparent;
      }
      canvas {
        display: block;
        background: transparent;
        cursor: crosshair;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <script>
      console.log('drawing.html loaded');
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');

      // 設定 Canvas 大小為螢幕大小
      canvas.width = window.screen.width;
      canvas.height = window.screen.height;

      // 繪圖設定
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 5;
      ctx.lineCap = 'round';

      let isDrawing = false;
      let lastX = 0;
      let lastY = 0;
      let activeTool = 'brush1'; // 預設工具
      const shapes = []; // 用於儲存畫筆的形狀資料
      let tempRectangleShape = null; // 用於儲存目前繪製長方形的暫存資料
      let startX = 0;
      let startY = 0;

      function drawRectangle(x1, y1, x2, y2) {
        ctx.strokeStyle = 'blue';
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.rect(x1, y1, x2 - x1, y2 - y1);
        ctx.stroke();
      }

      function draw(e) {
        if (!isDrawing) return;
        // console.log('drawing...');
        if (activeTool === 'brush1') {
          ctx.strokeStyle = 'red';
          ctx.lineWidth = 5;
          ctx.beginPath();
          ctx.moveTo(lastX, lastY);
          ctx.lineTo(e.clientX, e.clientY);
          ctx.stroke();
          shapes.push({
            type: 'brush1',
            x1: lastX,
            y1: lastY,
            x2: e.clientX,
            y2: e.clientY,
          });
        } else if (activeTool === 'Trail Pen') {
          ctx.strokeStyle = 'orange';
          ctx.lineWidth = 5;
          ctx.beginPath();
          ctx.moveTo(lastX, lastY);
          ctx.lineTo(e.clientX, e.clientY);
          ctx.stroke();
          shapes.push({
            type: 'Trail Pen',
            x1: lastX,
            y1: lastY,
            x2: e.clientX,
            y2: e.clientY,
            timestamp: Date.now(),
          });
        } else if (activeTool === 'Rectangle') {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.stroke();

          tempRectangleShape = {
            type: 'Rectangle',
            x1: startX,
            y1: startY,
            x2: e.clientX,
            y2: e.clientY,
          };
        }

        lastX = e.clientX;
        lastY = e.clientY;
      }

      function redrawCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        for (const shape of shapes) {
          if (shape.type === 'brush1') {
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(shape.x1, shape.y1);
            ctx.lineTo(shape.x2, shape.y2);
            ctx.stroke();
          } else if (shape.type === 'Trail Pen') {
            const age = Date.now() - shape.timestamp;
            const opacity = 1 - age / 5000; // 5秒淡出
            if (opacity > 0) {
              ctx.strokeStyle = `rgba(255, 165, 0, ${opacity})`; // 橘色
              ctx.lineWidth = 5;
              ctx.beginPath();
              ctx.moveTo(shape.x1, shape.y1);
              ctx.lineTo(shape.x2, shape.y2);
              ctx.stroke();
            }
          } else if (shape.type === 'Rectangle') {
            drawRectangle(shape.x1, shape.y1, shape.x2, shape.y2);
          }
        }

        // 繪製目前正在繪製的長方形
        if (tempRectangleShape) {
          drawRectangle(
            tempRectangleShape.x1,
            tempRectangleShape.y1,
            tempRectangleShape.x2,
            tempRectangleShape.y2,
          );
        }
      }

      function animateShapes() {
        redrawCanvas(); // 每次動畫幀都重新繪製所有內容
        // 移除過期的 Trail Pen 筆跡
        for (let i = 0; i < shapes.length; i++) {
          if (shapes[i].type === 'Trail Pen') {
            const age = Date.now() - shapes[i].timestamp;
            if (age / 5000 > 1) {
              shapes.splice(i, 1);
              i--;
            }
          }
        }
        requestAnimationFrame(animateShapes);
      }

      // 監聽來自主進程的 clear-drawing 訊息
      window.electronAPI.on('clear-drawing', () => {
        console.log('clear-drawing received in renderer');
        shapes.length = 0; // 清除所有形狀
        // redrawCanvas();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      });

      // 監聽來自主進程的 set-tool 訊息
      window.electronAPI.on('set-tool', (tool) => {
        console.log('set-tool received in renderer', tool);
        activeTool = tool;
      });

      // 初始繪製
      animateShapes();

      canvas.addEventListener('mousedown', (e) => {
        console.log('mousedown', e.clientX, e.clientY);
        isDrawing = true;
        lastX = e.clientX;
        lastY = e.clientY;
        startX = e.clientX; // 記錄長方形的起始點
        startY = e.clientY;
      });

      canvas.addEventListener('mousemove', draw);

      canvas.addEventListener('mouseup', (e) => {
        console.log('mouseup');
        isDrawing = false;
        tempRectangleShape = null; // 清除暫存的長方形資料
        if (activeTool === 'Rectangle') {
          shapes.push({ type: 'Rectangle', x1: startX, y1: startY, x2: e.clientX, y2: e.clientY });
          redrawCanvas();
        }
      });

      canvas.addEventListener('mouseout', () => {
        console.log('mouseout');
        isDrawing = false;
      });

      canvas.addEventListener('mouseleave', () => {
        console.log('mouseleave');
        isDrawing = false;
      });
    </script>
  </body>
</html>
