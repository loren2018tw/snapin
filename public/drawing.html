<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SnapIn</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: transparent;
      }
      canvas {
        display: block;
        background: transparent;
        cursor: crosshair;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <script>
      console.log('drawing.html loaded');
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');

      // 設定 Canvas 大小為螢幕大小
      canvas.width = window.screen.width;
      canvas.height = window.screen.height;

      // 繪圖設定
      let settings = {
        pen1Color: 'red',
        traceColor: 'orange',
        rectColor: 'blue',
        lineWidth: 5,
      };
      ctx.lineCap = 'round';

      let isDrawing = false;
      let lastX = 0;
      let lastY = 0;
      let activeTool = 'brush1'; // 預設工具
      const shapes = []; // 用於儲存畫筆的形狀資料
      let tempRectangleShape = null; // 用於儲存目前繪製長方形的暫存資料
      let tempEllipseShape = null; // 用於儲存目前繪製橢圓形的暫存資料
      let startX = 0;
      let startY = 0;

      function drawRectangle(x1, y1, x2, y2, color, width) {
        ctx.strokeStyle = color;
        ctx.lineWidth = width;
        ctx.beginPath();
        ctx.rect(x1, y1, x2 - x1, y2 - y1);
        ctx.stroke();
      }

      function drawEllipse(x, y, radiusX, radiusY, color, width) {
        ctx.strokeStyle = color;
        ctx.lineWidth = width;
        ctx.beginPath();
        ctx.ellipse(x, y, radiusX, radiusY, 0, 0, 2 * Math.PI);
        ctx.stroke();
      }

      function draw(e) {
        if (!isDrawing) return;
        // console.log('drawing...');
        if (activeTool === 'brush1') {
          ctx.strokeStyle = settings.pen1Color;
          ctx.lineWidth = settings.lineWidth;
          ctx.beginPath();
          ctx.moveTo(lastX, lastY);
          ctx.lineTo(e.clientX, e.clientY);
          ctx.stroke();
          shapes.push({
            type: 'brush1',
            x1: lastX,
            y1: lastY,
            x2: e.clientX,
            y2: e.clientY,
            color: settings.pen1Color,
            width: settings.lineWidth,
          });
        } else if (activeTool === 'Trail Pen') {
          ctx.strokeStyle = settings.traceColor;
          ctx.lineWidth = settings.lineWidth;
          ctx.beginPath();
          ctx.moveTo(lastX, lastY);
          ctx.lineTo(e.clientX, e.clientY);
          ctx.stroke();
          shapes.push({
            type: 'Trail Pen',
            x1: lastX,
            y1: lastY,
            x2: e.clientX,
            y2: e.clientY,
            timestamp: Date.now(),
            color: settings.traceColor,
            width: settings.lineWidth,
          });
        } else if (activeTool === 'Rectangle') {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.stroke();

          tempRectangleShape = {
            type: 'Rectangle',
            x1: startX,
            y1: startY,
            x2: e.clientX,
            y2: e.clientY,
            color: settings.rectColor,
            width: settings.lineWidth,
          };
        } else if (activeTool === 'Ellipse') {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.stroke();

          const radiusX = Math.abs(e.clientX - startX) / 2;
          const radiusY = Math.abs(e.clientY - startY) / 2;
          const centerX = startX + (e.clientX >= startX ? radiusX : -radiusX);
          const centerY = startY + (e.clientY >= startY ? radiusY : -radiusY);

          tempEllipseShape = {
            type: 'Ellipse',
            x: centerX,
            y: centerY,
            radiusX: radiusX,
            radiusY: radiusY,
            color: settings.rectColor,
            width: settings.lineWidth,
          };
        }

        lastX = e.clientX;
        lastY = e.clientY;
      }

      function redrawCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        for (const shape of shapes) {
          if (shape.type === 'brush1') {
            ctx.strokeStyle = shape.color;
            ctx.lineWidth = shape.width;
            ctx.beginPath();
            ctx.moveTo(shape.x1, shape.y1);
            ctx.lineTo(shape.x2, shape.y2);
            ctx.stroke();
          } else if (shape.type === 'Trail Pen') {
            const age = Date.now() - shape.timestamp;
            const opacity = 1 - age / 5000; // 5秒淡出
            if (opacity > 0) {
              const r = parseInt(shape.color.slice(1, 3), 16);
              const g = parseInt(shape.color.slice(3, 5), 16);
              const b = parseInt(shape.color.slice(5, 7), 16);
              ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
              ctx.lineWidth = shape.width;
              ctx.beginPath();
              ctx.moveTo(shape.x1, shape.y1);
              ctx.lineTo(shape.x2, shape.y2);
              ctx.stroke();
            }
          } else if (shape.type === 'Rectangle') {
            drawRectangle(shape.x1, shape.y1, shape.x2, shape.y2, shape.color, shape.width);
          } else if (shape.type === 'Ellipse') {
            drawEllipse(shape.x, shape.y, shape.radiusX, shape.radiusY, shape.color, shape.width);
          }
        }

        // 繪製目前正在繪製的長方形
        if (tempRectangleShape) {
          drawRectangle(
            tempRectangleShape.x1,
            tempRectangleShape.y1,
            tempRectangleShape.x2,
            tempRectangleShape.y2,
            tempRectangleShape.color,
            tempRectangleShape.width,
          );
        }

        // 繪製目前正在繪製的橢圓形
        if (tempEllipseShape) {
          drawEllipse(
            tempEllipseShape.x,
            tempEllipseShape.y,
            tempEllipseShape.radiusX,
            tempEllipseShape.radiusY,
            tempEllipseShape.color,
            tempEllipseShape.width,
          );
        }
      }

      function animateShapes() {
        redrawCanvas(); // 每次動畫幀都重新繪製所有內容
        // 移除過期的 Trail Pen 筆跡
        for (let i = 0; i < shapes.length; i++) {
          if (shapes[i].type === 'Trail Pen') {
            const age = Date.now() - shapes[i].timestamp;
            if (age / 5000 > 1) {
              shapes.splice(i, 1);
              i--;
            }
          }
        }
        requestAnimationFrame(animateShapes);
      }

      // 監聽來自主進程的 clear-drawing 訊息
      window.electronAPI.on('clear-drawing', () => {
        console.log('clear-drawing received in renderer');
        shapes.length = 0; // 清除所有形狀
        // redrawCanvas();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      });

      // 監聽來自主進程的 set-tool 訊息
      window.electronAPI.on('set-tool', (tool) => {
        console.log('set-tool received in renderer', tool);
        activeTool = tool;
        if (tool === 'Mouse Pointer') {
          canvas.style.cursor = 'default';
        } else {
          canvas.style.cursor = 'crosshair';
        }
      });

      window.electronAPI.on('update-settings', (newSettings) => {
        console.log('update-settings received in renderer', newSettings);
        settings = newSettings;
      });

      // 初始繪製
      animateShapes();

      canvas.addEventListener('mousedown', (e) => {
        console.log('mousedown', e.clientX, e.clientY);
        window.electronAPI.send('drawing-mousedown');
        isDrawing = true;
        lastX = e.clientX;
        lastY = e.clientY;
        startX = e.clientX; // 記錄長方形的起始點
        startY = e.clientY;
      });

      canvas.addEventListener('mousemove', draw);

      canvas.addEventListener('mouseup', (e) => {
        console.log('mouseup');
        isDrawing = false;
        tempRectangleShape = null; // 清除暫存的長方形資料
        tempEllipseShape = null; // 清除暫存的橢圓形資料
        if (activeTool === 'Rectangle') {
          shapes.push({
            type: 'Rectangle',
            x1: startX,
            y1: startY,
            x2: e.clientX,
            y2: e.clientY,
            color: settings.rectColor,
            width: settings.lineWidth,
          });
          redrawCanvas();
        } else if (activeTool === 'Ellipse') {
          const radiusX = Math.abs(e.clientX - startX) / 2;
          const radiusY = Math.abs(e.clientY - startY) / 2;
          const centerX = startX + (e.clientX >= startX ? radiusX : -radiusX);
          const centerY = startY + (e.clientY >= startY ? radiusY : -radiusY);

          shapes.push({
            type: 'Ellipse',
            x: centerX,
            y: centerY,
            radiusX: radiusX,
            radiusY: radiusY,
            color: settings.rectColor,
            width: settings.lineWidth,
          });
          redrawCanvas();
        }
      });

      canvas.addEventListener('mouseout', () => {
        console.log('mouseout');
        isDrawing = false;
      });

      canvas.addEventListener('mouseleave', () => {
        console.log('mouseleave');
        isDrawing = false;
      });

      // 添加鍵盤事件監聽器用於快速鍵
      window.addEventListener('keydown', (e) => {
        console.log('keydown in drawing', e.key);
        window.electronAPI.send('hotkey-pressed', e.key.toLowerCase());
      });
    </script>
  </body>
</html>
